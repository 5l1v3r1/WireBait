---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by markus.
--- DateTime: 2/15/19 11:20 PM
---

-- Unlike other libraries, function are capitalized to avoid lua syntax errors

local Bitwise = {};

--[[Bitwise operations]]
local UINT32_MAX = 0xFFFFFFFF;-- 32 bit word
local WORD_MASK = UINT32_MAX;

function Bitwise.And(int1, int2) --TODO: enforce uint32 params!
    assert(int1 and type(int1) == "number" and math.floor(int1) == int1, "Expecting integer");
    assert(int2 and type(int2) == "number" and math.floor(int2) == int2, "Expecting integer");
    return bit32.band(int1, int2);
end

function Bitwise.Lshift(int1, int2)
    assert(int1 and type(int1) == "number" and math.floor(int1) == int1, "Expecting integer");
    assert(int2 and type(int2) == "number" and math.floor(int2) == int2, "Expecting integer");
    return int1 * math.pow(2,int2);
end

function Bitwise.Rshift(int1, int2)
    assert(int1 and type(int1) == "number" and math.floor(int1) == int1, "Expecting integer");
    assert(int2 and type(int2) == "number" and math.floor(int2) == int2, "Expecting integer");
    return bit32.rshift(int1, int2);
end

function Bitwise.Or(int1, int2)
    assert(int1 and type(int1) == "number" and math.floor(int1) == int1, "Expecting integer");
    assert(int2 and type(int2) == "number" and math.floor(int2) == int2, "Expecting integer");
    return bit32.bor(int1, int2);
end

function Bitwise.Xor(int1, int2)
    assert(int1 and type(int1) == "number" and math.floor(int1) == int1, "Expecting integer");
    assert(int2 and type(int2) == "number" and math.floor(int2) == int2, "Expecting integer");
    return bit32.bxor(int1, int2);
end

function Bitwise.Not(int1)
    assert(int1 and type(int1) == "number" and math.floor(int1) == int1, "Expecting unsigned");
    return bit32.bnot(int1);
end

--[[Two's complement of a 64 bit value represented by two 4-byte values]]
function Bitwise.twosComplement(low_word, high_word)
    local new_low_word = Bitwise.And(Bitwise.Not(low_word), WORD_MASK) + 1;
    local new_high_word = Bitwise.And(Bitwise.Not(high_word), WORD_MASK);
    if new_low_word > WORD_MASK then --there's a carry from low to high word
        new_low_word = 0;
        new_high_word = Bitwise.And((new_high_word + 1), WORD_MASK);
    end
    return new_low_word, new_high_word;
end

return Bitwise;