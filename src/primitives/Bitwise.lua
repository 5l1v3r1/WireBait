---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by markus.
--- DateTime: 2/15/19 11:20 PM
---

-- Unlike other libraries, function are capitalized to avoid lua syntax errors

local Bitwise = {};

--[[Bitwise operations]]
local UINT32_MAX = 0xFFFFFFFF;-- 32 bit word
local WORD_MASK = UINT32_MAX;

function Bitwise.And(int1, int2) --TODO: enforce uint32 params!
    assert(int1 and type(int1) == "number" and math.floor(int1) == int1, "Expecting integer");
    assert(int2 and type(int2) == "number" and math.floor(int2) == int2, "Expecting integer");
    return bit32.band(int1, int2);
end

function Bitwise.Lshift(int1, int2)
    assert(int1 and type(int1) == "number" and math.floor(int1) == int1, "Expecting integer");
    assert(int2 and type(int2) == "number" and math.floor(int2) == int2, "Expecting integer");
    return int1 * math.pow(2,int2);
end

function Bitwise.Rshift(int1, int2)
    assert(int1 and type(int1) == "number" and math.floor(int1) == int1, "Expecting integer");
    assert(int2 and type(int2) == "number" and math.floor(int2) == int2, "Expecting integer");
    return bit32.rshift(int1, int2);
end

function Bitwise.Or(int1, int2)
    assert(int1 and type(int1) == "number" and math.floor(int1) == int1, "Expecting integer");
    assert(int2 and type(int2) == "number" and math.floor(int2) == int2, "Expecting integer");
    return bit32.bor(int1, int2);
end

function Bitwise.Xor(int1, int2)
    assert(int1 and type(int1) == "number" and math.floor(int1) == int1, "Expecting integer");
    assert(int2 and type(int2) == "number" and math.floor(int2) == int2, "Expecting integer");
    return bit32.bxor(int1, int2);
end

function Bitwise.Not(int1)
    assert(int1 and type(int1) == "number" and math.floor(int1) == int1, "Expecting unsigned");
    return bit32.bnot(int1);
end

return Bitwise;