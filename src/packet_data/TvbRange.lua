---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by markus.
--- DateTime: 2/16/19 12:04 PM
---

function TvbRange.new(data_as_hex_string, offset)
    assert(type(data_as_hex_string) == 'string', "TvbRange should be based on an hexadecimal string!")
    data_as_hex_string = data_as_hex_string:gsub("%s+","") --removing white spaces
    assert(not data_as_hex_string:find('%X'), "String should be hexadecimal!")
    assert(string.len(data_as_hex_string) % 2 == 0, "String has its last byte cut in half!")

    local tvb_range = {
        _struct_type = "TvbRange",
        m_data_as_hex_str = data_as_hex_string:upper(),
        m_offset = offset or 0;
    }
    local escape_replacements = {["\0"]="\\0", ["\t"]="\\t", ["\n"]="\\n", ["\r"]="\\r", }

    function tvb_range:len()
        return math.floor(string.len(self.m_data_as_hex_str)/2);
    end

    function tvb_range:reported_length_remaining()
        --TODO: work on this!    
        --TODO: work on this!
        --TODO: work on this!
        --TODO: work on this!
        --TODO: work on this!

        --print("[WARNING] tvb:reported_length_remaining() is not supported yet and returns len()!");
        return math.floor(string.len(self.m_data_as_hex_str)/2);
    end

    function tvb_range:tvb()
        --TODO: create a tvb out of the TvbRange
    end

    function tvb_range:none()
        local str = ""
        return str
    end

    function tvb_range:uint()
        assert(self:len() <= 4, "tvbrange:uint() cannot decode more than 4 bytes! (len = " .. self:len() .. ")");
        return hexStringToUint32(self:bytes());
    end

    function tvb_range:uint64()
        assert(self:len() <= 8, "tvbrange:uint64() cannot decode more than 8 bytes! (len = " .. self:len() .. ")");
        return UInt64.fromHex(self:bytes());
    end;

    function tvb_range:le_uint()
        assert(self:len() <= 4, "tvbrange:le_uint() cannot decode more than 4 bytes! (len = " .. self:len() .. ")");
        return hexStringToUint32(utils.swapBytes(self:bytes()));
    end

    function tvb_range:le_uint64()
        assert(self:len() <= 8, "tvbrange:le_uint64() cannot decode more than 8 bytes! (len = " .. self:len() .. ")");
        return UInt64.fromHex(utils.swapBytes(self:bytes()));
    end;

    function tvb_range:int(mask)
        local size = self:len();
        assert(size >= 1 and size <= 4, "TvbRange must be between 1 and 4 bytes long for TvbRange:int() to work. (TvbRange size: " .. self:len() ..")");
        local uint = self:uint();
        if mask then
            assert(type(mask) == "number" and mask == math.floor(mask) and mask <= UINT32_MAX, "When provided, the mask should be a 32 bit unsigned integer!");
            uint = bwAnd(uint, mask);
        end
        local sign_mask=tonumber("80" .. string.rep("00", size-1), 16);
        if bwAnd(uint, sign_mask) > 0 then --we're dealing with a negative number
            local val_mask=tonumber("7F" .. string.rep("FF", size-1), 16);
            local val = -(bwAnd(bwNot(uint), val_mask) + 1);
            return val;
        else --we are dealing with a positive number
            return uint;
        end
    end

    function tvb_range:le_int(mask)
        local size = self:len();
        assert(size == 1 or size == 2 or size == 4, "TvbRange must be 1, 2, or 4 bytes long for TvbRange:le_int() to work. (TvbRange size: " .. self:len() ..")");
        return TvbRange.new(utils.swapBytes(self:bytes())):int(mask);
    end

    function tvb_range:int64(mask)
        if mask then
            return Int64.fromHex(self:bytes()):band(mask)
        end
        return Int64.fromHex(self:bytes());
    end

    function tvb_range:le_int64(mask)
        local size = self:len();
        assert(size == 1 or size == 2 or size == 4 or size == 8, "TvbRange must be 1, 2, 4, or 8 bytes long for TvbRange:le_int() to work. (TvbRange size: " .. self:len() ..")");
        return TvbRange.new(utils.swapBytes(self:bytes())):int64(mask);
    end

    function tvb_range:float()
        local size = self:len();
        assert(size == 4 or size == 8, "TvbRange must be 4 or 8 bytes long for TvbRange:float() to work. (TvbRange size: " .. self:len() ..")");
        if size == 4 then --32 bit float
            local uint = self:uint();
            --Handling special values nicely
            if uint == 0 or uint == 0x80000000 then
                return 0; --[[+/- zero]]
            elseif uint == 0x7F800000 then
                return math.huge --[[+infinity]]
            elseif uint == 0xFF800000 then
                return -math.huge --[[-infinity]]
            end
            local bit_len = 23;
            local exponent_mask = 0x7F800000;
            local exp = bwRshift(bwAnd(uint, exponent_mask), bit_len);
            local fraction= 1;
            for i=1,bit_len do
                local bit_mask = bwLshift(1, (bit_len-i)); --looking at one bit at a time
                if bwAnd(bit_mask, uint) > 0 then
                    fraction = fraction + math.pow(2,-i)
                end
            end
            local absolute_value = fraction * math.pow(2, exp -127);
            local sign = bwAnd(uint, 0x80000000) > 0 and -1 or 1;
            return sign * absolute_value;
        else --64 bit float
            local word1 = self(0,4):uint(); --word1 will contain the bit sign, the exponent and part of the fraction
            local word2 = self(4,4):uint(); --word2 will contain the rest of the fraction
            --Handling special values nicely
            if word2 == 0 then
                if word1 == 0 or word1 == 0x80000000 then
                    return 0; --[[+/-zero]]
                elseif word1 == 0x7FF00000 then
                    return math.huge --[[+infinity]]
                elseif word1 == 0xFFF00000 then
                    return -math.huge --[[-infinity]]
                end
            end
            local exponent_mask = 0x7FF00000;
            local bit_len1 = 20;
            local exp = bwRshift(bwAnd(word1, exponent_mask), bit_len1);
            local fraction= 1;
            for i=1,bit_len1 do --[[starting to calculate fraction with word1]]
                local bit_mask = bwLshift(1, (bit_len1-i)); --looking at one bit at a time
                if bwAnd(bit_mask, word1) > 0 then
                    fraction = fraction + math.pow(2,-i)
                end
            end
            local bit_len2 = 32; --[[finishing to calculate fraction with word2]]
            for i=1,bit_len2 do
                local bit_mask = bwLshift(1, (bit_len2-i)); --looking at one bit at a time
                if bwAnd(bit_mask, word2) > 0 then
                    fraction = fraction + math.pow(2,-i-bit_len1)
                end
            end
            local absolute_value = fraction * math.pow(2, exp - 1023);
            local sign = bwAnd(word1, 0x80000000) > 0 and -1 or 1;
            return sign * absolute_value;
        end
    end

    function tvb_range:le_float()
        local size = self:len();
        assert(size == 4 or size == 8, "TvbRange must be 4 or 8 bytes long for TvbRange:le_float() to work. (TvbRange size: " .. self:len() ..")");
        return TvbRange.new(utils.swapBytes(self:bytes())):float();
    end

    function tvb_range:ipv4()
        assert(self:len() == 4, "TvbRange must by 4 bytes long for TvbRange:ipv4() to work. (TvbRange size: " .. self:len() ..")");
        return printIP(self:int());
    end

    function tvb_range:le_ipv4()
        assert(self:len() == 4, "TvbRange must by 4 bytes long for TvbRange:le_ipv4() to work. (TvbRange size: " .. self:len() ..")");
        return printIP(self:le_int());
    end

    function tvb_range:eth()
        assert(self:len() == 6, "TvbRange must by 6 bytes long for TvbRange:eth() to work. (TvbRange size: " .. self:len() ..")");
        local eth_addr = "";
        for i=1,self:len() do
            local sep = i == 1 and "" or ":";
            eth_addr = eth_addr .. sep .. self(i-1,1):bytes();
        end
        return string.lower(eth_addr);
    end

    function tvb_range:string()
        local str = ""
        for i=1,self:len() do
            local byte_ = self.m_data_as_hex_str:sub(2*i-1,2*i) --[[even a Protofield.string() stops printing after null character]]
            if byte_ == '00' then --null char termination
                return str
            end
            str = str .. string.char(tonumber(byte_, 16))
        end
        str = string.gsub(str, ".", escape_replacements) --replacing escaped characters that characters that would cause io.write() or print() to mess up is they were interpreted
        return str
    end

    function tvb_range:stringz()
        local str = ""
        for i=1,self:len()-1 do
            local byte_ = self.m_data_as_hex_str:sub(2*i-1,2*i)
            if byte_ == '00' then --null char termination
                return str
            end
            str = str .. string.char(tonumber(byte_, 16))
        end
        str = string.gsub(str, ".", escape_replacements) --replacing escaped characters that characters that would cause io.write() or print() to mess up is they were interpreted
        return str
    end

    --[[TODO: this is not utf-16]]
    function tvb_range:ustring()
        return self:string();
    end

    --[[TODO: this is not utf-16]]
    function tvb_range:ustringz()
        return self:stringz();
    end

    function tvb_range:le_ustring()
        local be_hex_str = swapBytes(self:bytes());
        return TvbRange.new(be_hex_str):ustring();
    end

    function tvb_range:le_ustringz()
        local be_hex_str = swapBytes(self:bytes());
        return TvbRange.new(be_hex_str):ustringz();
    end

    function tvb_range:bitfield(offset, length)
        offset = offset or 0;
        length = length or 1;
        assert(length <= 64, "Since bitfield() returns a uint64 of the bitfield, length must be <= 64 bits! (length: " .. length .. ")")
        local byte_offset = math.floor(offset/8);
        local byte_size = math.ceil((offset+length)/8) - byte_offset;
        local left_bits_count = offset % 8;
        local right_bits_count = (byte_size + byte_offset)*8 - (offset+length);
        assert(length == 8*byte_size - left_bits_count - right_bits_count); --[[number of bits up]]

        if length <= 32 then
            local uint_val = self(byte_offset, byte_size):uint64();
            local bit_mask = tonumber(string.rep("1", length),2);
            local uint64_masked_val = (uint_val:rshift(right_bits_count)):band(bit_mask);
            return uint64_masked_val:tonumber(); --since we're dealing with less than 32 bits, we can return a number

        else
            local high_bit_mask = tonumber(string.rep("1", 32 - left_bits_count),2);-- << left_bits_count;
            local bytes_as_uint64 = UInt64.fromHex(self(byte_offset, byte_size):bytes());
            return UInt64.new(bytes_as_uint64.m_low_word, bwAnd(bytes_as_uint64.m_high_word, high_bit_mask)):rshift(right_bits_count);
        end
    end

    function tvb_range:bytes()
        return self.m_data_as_hex_str;
    end

    function tvb_range:__guid()
        assert(self:len() == 16, "Trying to fetch a GUID with length " .. self:len() .. "(Expecting 16 bytes)");
        local s_ = self.m_data_as_hex_str;
        return string.lower(s_:sub(0,8) .. "-" .. s_:sub(9,12) .. "-" .. s_:sub(13,16) .. "-" .. s_:sub(17,20) .. "-" .. s_:sub(21));
    end

    function tvb_range:range(start, length)
        assert(start and start >= 0, "Start position should be positive positive!");
        length = length or self:len() - start; --add unit test for the case where no length was provided
        assert(length >= 0, "Length should be positive!");
        assert(start + length <= self:len(), "Index get out of bounds!")
        local offset = start;
        return TvbRange.new(string.sub(self.m_data_as_hex_str,2*start+1, 2*(start+length)), offset)
    end

    function tvb_range:offset()
        return self.m_offset;
    end

    function tvb_range:__call(start, length) --allows TvbRange to be called as a function
        return self:range(start, length);
    end

    function tvb_range:__tostring()
        if self:len() > 24 then --[[ellipsis after 24 bytes c.f. [tvbrange:__tostring()](https://wiki.wireshark.org/LuaAPI/Tvb#tvbrange:__tostring.28.29) ]]
            return string.format("%48s", string.lower(self.m_data_as_hex_str)) .. "...";
        end
        return  string.lower(self.m_data_as_hex_str);
    end

    setmetatable(tvb_range, tvb_range)

    return tvb_range;
end