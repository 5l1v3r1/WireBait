---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by markus.
--- DateTime: 2/15/19 11:35 PM
---

--[[ Data structure holding a packet in the form of an ethernet frame, which is used by wirebait to hold packets read from pcap files.
     At initialization, all the member of the struct are set to nil, which leaves the structure actually empty. The point here
     is that you can visualize what the struct would look like once populated]]
function Packet.new (packet_buffer, pkt_timestamp)
    local packet = {
        timestamp = {
            sec = pkt_timestamp.sec,
            u_sec = pkt_timestamp.u_sec,
        },
        ethernet = {
            dst_mac = nil, --string in hex format e.g. "EC086B703682" (which would correspond to the mac address ec:08:6b:70:36:82
            src_mac = nil,
            type = nil, --type as unsigned int, e.g. 0x0800 for IPV4
            ipv4 = {
                protocol = nil, --dissector as unsigned int, e.g. 0x06 for TCP
                dst_ip = nil, -- uint32 little endian
                src_ip = nil, -- uint32 little endian
                udp = {
                    src_port = nil,
                    dst_port = nil,
                    data = nil,
                },
                tcp = {
                    src_port = nil,
                    dst_port = nil,
                    data = nil,
                },
                other_data = nil, -- exist if pkt is not tcp nor udp
            },
            other_data = nil -- exist if pkt is not ip
        }
    }

    assert(packet_buffer and typeof(packet_buffer) == "buffer", "Packet cannot be constructed without a buffer!");
    --[[Ethernet layer parsing]]
    packet.ethernet.dst_mac = packet_buffer(0,6):bytes();
    packet.ethernet.src_mac = packet_buffer(6,6):bytes();
    packet.ethernet.type = packet_buffer(12,2):uint(); --e.g 0x0800 for IP
    if packet.ethernet.type ~= PROTOCOL_TYPES.IPV4 then
        packet.ethernet.other = packet_buffer(14,packet_buffer:len() - 14);
    else
        --[[IPV4 layer parsing]]
        packet.ethernet.ipv4.protocol = packet_buffer(23,1):uint();
        packet.ethernet.ipv4.src_ip = packet_buffer(26,4):uint();
        packet.ethernet.ipv4.dst_ip = packet_buffer(30,4):uint();

        --[[UDP layer parsing]]
        if packet.ethernet.ipv4.protocol == PROTOCOL_TYPES.UDP then
            packet.ethernet.ipv4.udp.src_port = packet_buffer(34,2):uint();
            packet.ethernet.ipv4.udp.dst_port = packet_buffer(36,2):uint();
            assert(packet_buffer:len() >= 42, "Packet buffer is of invalid size!")
            packet.ethernet.ipv4.udp.data = packet_buffer(42,packet_buffer:len() - 42);
        elseif packet.ethernet.ipv4.protocol == PROTOCOL_TYPES.TCP then
        --[[TCP layer parsing]]
            packet.ethernet.ipv4.tcp.src_port = packet_buffer(34,2):uint();
            packet.ethernet.ipv4.tcp.dst_port = packet_buffer(36,2):uint();
            local tcp_hdr_len = 4 * bwRshift(bwAnd(packet_buffer(46,1):uint(), 0xF0), 4);
            local tcp_payload_start_index = 34 + tcp_hdr_len;
            assert(packet_buffer:len() >= tcp_payload_start_index, "Packet buffer is of invalid size!")
            packet.ethernet.ipv4.tcp.data = packet_buffer(tcp_payload_start_index, packet_buffer:len() - tcp_payload_start_index);
        else
        --[[Unknown transport layer]]
            packet.ethernet.ipv4.other = packet_buffer(14,packet_buffer:len() - 14);
        end
    end

    function packet:getIPProtocol()
        return self.ethernet.ipv4.protocol;
    end

    function packet:getSrcIP()
        return printIP(self.ethernet.ipv4.src_ip);
    end

    function packet:getDstIP()
        return printIP(self.ethernet.ipv4.dst_ip);
    end

    function packet:getSrcPort()
        local ip_proto = self:getIPProtocol();
        if ip_proto == PROTOCOL_TYPES.UDP then
            return self.ethernet.ipv4.udp.src_port
        elseif ip_proto == PROTOCOL_TYPES.TCP then
            return self.ethernet.ipv4.tcp.src_port
        else
            error("Packet currently only support getSrcPort() for IP/UDP and IP/TCP protocols!")
        end
    end

    function packet:getDstPort()
        local ip_proto = self:getIPProtocol();
        if ip_proto == PROTOCOL_TYPES.UDP then
            return self.ethernet.ipv4.udp.dst_port
        elseif ip_proto == PROTOCOL_TYPES.TCP then
            return self.ethernet.ipv4.tcp.dst_port
        else
            error("Packet currently only support getDstPort() for IP/UDP and IP/TCP protocols!")
        end
    end

    function packet:protocol()
        local ip_proto = self:getIPProtocol();
        if ip_proto == PROTOCOL_TYPES.UDP then
            return "UDP";
        elseif ip_proto == PROTOCOL_TYPES.TCP then
            return "TCP";
        else
            error("packet_info:dissector() only supports IP/UDP and IP/TCP protocols!")
        end
    end

    function packet:len()
        local ip_proto = self:getIPProtocol();
        if ip_proto == PROTOCOL_TYPES.UDP then
            return self.ethernet.ipv4.udp.data:len();
        elseif ip_proto == PROTOCOL_TYPES.TCP then
            return self.ethernet.ipv4.tcp.data:len();
        else
            error("Packet:len() only supports IP/UDP and IP/TCP protocols!")
        end
    end

    function packet:printInfo(frame_number, cols)
        local function ellipsis(value, char_count)
            local val_str = tostring(value);
            if #val_str > char_count then
                return val_str:sub(0,char_count-3) .. "..";
            end
            return val_str;
        end
        assert(self.ethernet.type == PROTOCOL_TYPES.IPV4, "Only IPv4 packets are supported!");
        local src = self:getSrcIP();
        local dst = self:getDstIP();
        local src_port = self:getSrcPort();
        local dst_port = self:getDstPort();
        local length = (self.ethernet.ipv4.udp.data or self.ethernet.ipv4.tcp.data):len();
        --[[Creating a UTC timestamp string.
        For instance: if the date is sept 1st 2017 2:02 am  the timestamp will be "2017-09-01 02:02:47.23864" ]]
        --local timestamp_str = os.date("!%Y-%m-%d", self.timestamp.sec) .. " " .. os.date("!%H:%M:%S.".. self.timestamp.u_sec , self.timestamp.sec)
        local timestamp_str = os.date("!%H:%M:%S.".. self.timestamp.u_sec , self.timestamp.sec) --only displaying the time
        io.write(string.format("%-12s| %-20s| %-18s| %-18s| %-10s| %-10s| %-50s\n",
                "No.", "Time", "Source", "Destination", "Protocol", "Length", "Info"));
        io.write(string.format("%-12s| %-20s| %-18s| %-18s| %-10s| %-10d| %-50s\n",
                frame_number, ellipsis(timestamp_str, 20), src, dst, ellipsis(cols.protocol,10), length, ellipsis(cols.info, 50)));
    end

    return packet;
end